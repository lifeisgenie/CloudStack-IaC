# ==============================
# 공통 패키지 + containerd + kubeadm 설치 (master)
# ==============================

- name: Swap 비활성화
  become: yes
  command: swapoff -a
  ignore_errors: yes

- name: fstab의 swap 주석 처리
  become: yes
  replace:
    path: /etc/fstab
    regexp: '^([^#].*\sswap\s.*)$'
    replace: '# \1'

# ---------- 커널 / sysctl 설정 ----------
- name: br_netfilter 모듈 로드
  become: yes
  modprobe:
    name: br_netfilter
    state: present

- name: net.ipv4.ip_forward = 1 설정
  become: yes
  sysctl:
    name: net.ipv4.ip_forward
    value: '1'
    state: present
    reload: yes

# 브리지 트래픽 설정 - 없다고 에러나진 않지만, k8s 베스트 프랙티스

- name: net.bridge.bridge-nf-call-iptables = 1 설정
  become: yes
  sysctl:
    name: net.bridge.bridge-nf-call-iptables
    value: '1'
    state: present
    reload: yes
  ignore_errors: yes  # br_netfilter 모듈 없는 경우 대비

- name: net.bridge.bridge-nf-call-ip6tables = 1 설정
  become: yes
  sysctl:
    name: net.bridge.bridge-nf-call-ip6tables
    value: '1'
    state: present
    reload: yes
  ignore_errors: yes

# ---------- containerd ----------

- name: 필수 패키지 설치
  become: yes
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg
      - lsb-release
    state: present
    update_cache: yes

- name: containerd 설치
  become: yes
  apt:
    name: containerd
    state: present

- name: /etc/containerd 디렉토리 생성
  become: yes
  file:
    path: /etc/containerd
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: containerd config 생성
  become: yes
  shell: |
    containerd config default | tee /etc/containerd/config.toml >/dev/null
  args:
    creates: /etc/containerd/config.toml

- name: containerd SystemdCgroup 적용
  become: yes
  replace:
    path: /etc/containerd/config.toml
    regexp: 'SystemdCgroup = false'
    replace: 'SystemdCgroup = true'

- name: containerd 재시작
  become: yes
  systemd:
    name: containerd
    enabled: yes
    state: restarted

# ---------- Kubernetes repo 설정 ----------

- name: apt keyring 디렉토리 생성
  become: yes
  file:
    path: /etc/apt/keyrings
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: K8s GPG key 추가
  become: yes
  shell: |
    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key \
      | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
  args:
    creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg

- name: Kubernetes repo 추가
  become: yes
  copy:
    dest: /etc/apt/sources.list.d/kubernetes.list
    content: |
      deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /

- name: kubeadm/kubelet/kubectl 설치
  become: yes
  apt:
    name:
      - kubeadm
      - kubelet
      - kubectl
    state: present
    update_cache: yes

# ---------- kubeadm init ----------

- name: kubeadm init 실행
  become: yes
  command: >
    kubeadm init
    --pod-network-cidr=192.168.0.0/16
    --cri-socket unix:///run/containerd/containerd.sock
    --ignore-preflight-errors=NumCPU
  args:
    creates: /etc/kubernetes/admin.conf
  register: init

# ---------- kubeconfig 설정 ----------

- name: ubuntu kubeconfig 디렉토리 생성
  become: yes
  file:
    path: /home/ubuntu/.kube
    state: directory
    owner: ubuntu
    group: ubuntu
    mode: "0700"

- name: admin.conf 복사
  become: yes
  copy:
    src: /etc/kubernetes/admin.conf
    dest: /home/ubuntu/.kube/config
    owner: ubuntu
    group: ubuntu
    mode: "0600"
    remote_src: yes

# ---------- CNI 설치 - Calico ----------

- name: Calico 설치
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.31.1/manifests/calico.yaml
    
- name: Calico Ready 확인
  shell: kubectl -n calico-system wait --for=condition=available deployment/calico-kube-controllers --timeout=120s
  changed_when: false
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config

# ---------- Local Path Provisioner 설치 ----------
- name: local-path-provisioner 설치
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

- name: local-path-provisioner를 default StorageClass로 지정
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    kubectl patch storageclass local-path \
      -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

# ---------- MetalLB 설치 및 설정 ----------

# 1) control-plane/master taint 제거 (single-node cluster 용)
- name: control-plane/master taint 제거 (single-node cluster 용)
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    set -eux
    kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
    kubectl taint nodes --all node-role.kubernetes.io/master- || true

# 2) MetalLB 메인 매니페스트 적용
- name: MetalLB 설치
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.8/config/manifests/metallb-native.yaml

# 3) MetalLB controller Ready 대기 (webhook은 기다리지 않음)
- name: MetalLB controller Ready 대기
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  shell: |
    set -eux
    kubectl -n metallb-system wait --for=condition=available deployment/controller --timeout=180s
  register: metallb_wait
  changed_when: false   # 상태 체크용

# 4) IPAddressPool + L2Advertisement YAML 생성
- name: MetalLB IP Pool 구성 파일 생성
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  copy:
    dest: /home/ubuntu/metallb.yaml
    content: |
      apiVersion: metallb.io/v1beta1
      kind: IPAddressPool
      metadata:
        name: default-address-pool
        namespace: metallb-system
      spec:
        addresses:
        - 192.168.100.200-192.168.100.250

      ---
      apiVersion: metallb.io/v1beta1
      kind: L2Advertisement
      metadata:
        name: l2adv
        namespace: metallb-system

# 5) IP Pool 적용 (controller 대기가 성공했을 때만)
- name: MetalLB IP Pool 적용
  become: yes
  become_user: ubuntu
  environment:
    KUBECONFIG: /home/ubuntu/.kube/config
  command: kubectl apply -f /home/ubuntu/metallb.yaml
  when: metallb_wait.rc == 0

# ---------- Worker join 명령 생성 ----------

- name: kubeadm join 명령 생성
  become: yes
  command: kubeadm token create --print-join-command
  register: join_cmd

- name: join command fact 저장
  set_fact:
    join_command: "{{ join_cmd.stdout }} --cri-socket unix:///run/containerd/containerd.sock --ignore-preflight-errors=NumCPU"